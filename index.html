<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Arix Signature Interactive Christmas Tree</title>

  <!-- 字体：中文祝福更稳 -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&family=Noto+Sans+SC:wght@400;600;700&display=swap" rel="stylesheet">

  <style>
    :root{
      --bg:#020806;
      --emerald:#0b3b2e;
      --gold:#d4af37;
      --goldHi:#ffd68a;
      --text:#eaeaea;
    }

    html,body{height:100%;margin:0;background:radial-gradient(circle at top, #06261d, var(--bg)); overflow:hidden;}
    body{font-family: Inter,"Noto Sans SC",system-ui,-apple-system,Segoe UI,Roboto,"PingFang SC","Microsoft YaHei",sans-serif; color:var(--text);}

    #app{position:fixed; inset:0;}
    canvas.webgl{position:absolute; inset:0; width:100%; height:100%; display:block;}

    /* 顶部标题：金属流光 */
    .overlay-root{ position:fixed; inset:0; pointer-events:none; }
    .mc-title{
      position:absolute;
      top: 24px;
      left: 26px;
      font-size: 42px;
      letter-spacing: 0.06em;
      font-weight: 700;

      background: linear-gradient(
        110deg,
        rgba(255,214,138,0.95) 0%,
        rgba(212,175,55,1) 22%,
        rgba(255,245,210,0.98) 42%,
        rgba(212,175,55,1) 62%,
        rgba(255,214,138,0.95) 100%
      );
      background-size: 240% 100%;
      -webkit-background-clip: text;
      background-clip: text;
      color: transparent;

      filter: drop-shadow(0 10px 18px rgba(0,0,0,0.35))
              drop-shadow(0 0 22px rgba(212,175,55,0.18));
      animation: goldSweep 3.6s linear infinite;
      user-select:none;
    }
    @keyframes goldSweep{
      0%{ background-position: 0% 50%; }
      100%{ background-position: 240% 50%; }
    }

    /* 角落提示 */
    .hint{
      position:absolute; right:18px; bottom:18px;
      max-width: 360px;
      font-size: 12px;
      line-height: 1.5;
      opacity:.75;
      padding: 10px 12px;
      border-radius: 12px;
      background: rgba(0,0,0,0.35);
      border: 1px solid rgba(212,175,55,0.18);
      backdrop-filter: blur(10px);
      user-select:none;
    }
    .hint b{color:var(--goldHi); font-weight:600;}

    /* 手势线框 UI（你要求 bottom:55px） */
    .hand-tracker-container{
      position: fixed;
      left: 18px;
      bottom: 55px;
      width: 220px;
      height: 160px;
      pointer-events: none;
      border-radius: 14px;
      background: rgba(2, 8, 6, 0.55);
      border: 1px solid rgba(212, 175, 55, 0.22);
      box-shadow: 0 10px 28px rgba(0,0,0,0.35);
      backdrop-filter: blur(10px);
      overflow: hidden;
    }
    .hand-tracker-container canvas{
      width:100%; height:100%; display:block;
    }

    /* 权限按钮 */
    .perm{
      position:absolute; left:18px; top:92px;
      display:flex; gap:10px; align-items:center;
      pointer-events:auto;
    }
    .btn{
      border: 1px solid rgba(212,175,55,0.28);
      background: rgba(0,0,0,0.35);
      color: #fff;
      padding: 8px 10px;
      border-radius: 10px;
      cursor:pointer;
      font-size: 12px;
      backdrop-filter: blur(10px);
    }
    .btn:hover{ border-color: rgba(255,214,138,0.5); }
    .status{ font-size:12px; opacity:.8; }

    /*模拟小水印*/
    .brand{
      position:absolute; left:26px; top:74px;
      font-size:12px; opacity:.7; letter-spacing:.12em;
      color: rgba(234,234,234,0.75);
      user-select:none;
    }

  </style>
</head>
<body>
  <div id="app">
    <canvas class="webgl" id="c"></canvas>

    <div class="overlay-root">
      <div class="mc-title">Merry Christmas</div>
      <div class="brand">ARIX · SIGNATURE</div>

      <div class="perm">
        <button class="btn" id="btnCam">启用手势控制</button>
        <div class="status" id="camStatus">（未启用摄像头）</div>
      </div>

      <div class="hand-tracker-container" aria-hidden>
        <canvas id="handCanvas" width="220" height="160"></canvas>
      </div>

      <div class="hint">
        点击背景：<b>散落 / 成树</b><br/>
        手势：<b>张开=散落</b>，<b>握拳=成树</b>；<b>单手拖拽旋转</b>；<b>上下移动缩放</b>；<b>双捏合×2 聚焦/解锁文字</b><br/>
        点击任意祝福文本：直接聚焦
      </div>
    </div>
  </div>

<script type="module">
<!-- Three.js 非 module 版：更兼容手机/内置浏览器 -->
<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>

<script>
  // ===== 强制可见的调试 HUD（一定会出现） =====
  const hud = document.createElement("div");
  hud.style.cssText = "position:fixed;left:12px;top:140px;z-index:999999;background:rgba(0,0,0,.65);border:1px solid rgba(255,214,138,.35);color:#ffd68a;padding:10px 12px;border-radius:12px;font:12px/1.5 ui-monospace,Menlo,monospace;white-space:pre-wrap;max-width:92vw";
  hud.textContent = "JS: running...";
  document.body.appendChild(hud);
  // ===== WebGL 自检：把结果写到 HUD =====
let glInfo = "unknown";
try {
  const gl = renderer.getContext();
  glInfo = gl.getParameter(gl.VERSION);
} catch (e) {
  glInfo = "FAILED";
}
hud.textContent = `JS: running...\nWebGL: ${glInfo}`;

  // ===== 基础场景 =====
  const canvas = document.getElementById("c");
  const scene = new THREE.Scene();
  scene.fog = new THREE.FogExp2(0x020806, 0.06);

  const renderer = new THREE.WebGLRenderer({ canvas, antialias:true, alpha:true });
  renderer.setPixelRatio(Math.min(2, window.devicePixelRatio || 1));
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.outputColorSpace = THREE.SRGBColorSpace;
  renderer.toneMapping = THREE.ACESFilmicToneMapping;
  renderer.toneMappingExposure = 1.05;

  const camera = new THREE.PerspectiveCamera(38, window.innerWidth/window.innerHeight, 0.1, 100);
  camera.position.set(0, 1.3, 10);

  // 灯光
  scene.add(new THREE.AmbientLight(0xffffff, 0.25));
  const dir = new THREE.DirectionalLight(0xffffff, 2.2);
  dir.position.set(6,10,6);
  scene.add(dir);

  const p1 = new THREE.PointLight(0xFFD58A, 18, 22);
  p1.position.set(-4, 2, 4);
  scene.add(p1);

  const p2 = new THREE.PointLight(0x2AAE7B, 10, 18);
  p2.position.set(3, -1, -3);
  scene.add(p2);
// ===== 强制可见测试物体：如果看不到它，说明 WebGL 没在画 =====
const testBox = new THREE.Mesh(
  new THREE.BoxGeometry(1.2, 1.2, 1.2),
  new THREE.MeshBasicMaterial({ color: 0xff00ff }) // 紫色，极醒目
);
testBox.position.set(0, 0.4, 0);
scene.add(testBox);
  // ===== 状态机 =====
  const TreeMorphState = { SCATTERED:"SCATTERED", TREE_SHAPE:"TREE_SHAPE" };
  const morph = { current:TreeMorphState.SCATTERED, target:TreeMorphState.SCATTERED, morphT:0, speed:0.9 };

  function easeInOutCubic(t){
    return t < 0.5 ? 4*t*t*t : 1 - Math.pow(-2*t+2,3)/2;
  }

  // ===== 双位置系统 =====
  function rand01(seed){
    const x = Math.sin(seed * 9999.123) * 43758.5453;
    return x - Math.floor(x);
  }
  function generateScatterPosition(i, radius=7.2){
    const u = rand01(i*17.1), v = rand01(i*91.7), w = rand01(i*43.3);
    const theta = 2*Math.PI*u;
    const phi = Math.acos(2*v - 1);
    const r = radius * Math.pow(w, 0.25);
    return new THREE.Vector3(
      r * Math.sin(phi) * Math.cos(theta),
      r * Math.cos(phi),
      r * Math.sin(phi) * Math.sin(theta)
    );
  }
  function generateTreeConePosition(i, count, height=8.6, baseRadius=3.4){
    const t = i / Math.max(1, count-1);
    const yNorm = Math.pow(t, 0.78);
    const y = (yNorm - 0.5) * height;
    const radius = (1 - yNorm) * baseRadius;

    const goldenAngle = Math.PI * (3 - Math.sqrt(5));
    const angle = i * goldenAngle;

    const jitter = (rand01(i*12.77)-0.5) * 0.12 * radius;
    return new THREE.Vector3(
      Math.cos(angle) * (radius + jitter),
      y,
      Math.sin(angle) * (radius + jitter)
    );
  }
  function buildDualPositions(count){
    const out = new Array(count);
    for(let i=0;i<count;i++){
      out[i] = {
        scatter: generateScatterPosition(i, 7.2),
        tree: generateTreeConePosition(i, count, 8.6, 3.4),
        seed: rand01(i*101.13)
      };
    }
    return out;
  }

  // ===== 树主体（InstancedMesh） =====
  const treeGroup = new THREE.Group();
  scene.add(treeGroup);

  const tempObj = new THREE.Object3D();

  function makeLayer({count, geometry, material, scale=1}){
    const dual = buildDualPositions(count);
    const mesh = new THREE.InstancedMesh(geometry, material, count);
    mesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
    treeGroup.add(mesh);
    return { mesh, dual, count, scale };
  }

  const goldMat = new THREE.MeshStandardMaterial({
    color: new THREE.Color("#D4AF37"),
    metalness: 1,
    roughness: 0.18,
    emissive: new THREE.Color("#2A1A00"),
    emissiveIntensity: 0.35
  });

  const emeraldMat = new THREE.MeshPhysicalMaterial({
    color: new THREE.Color("#0B3B2E"),
    metalness: 0.15,
    roughness: 0.08,
    transmission: 0.65,
    thickness: 0.6,
    clearcoat: 1,
    clearcoatRoughness: 0.08,
    ior: 1.45,
    emissive: new THREE.Color("#06261D"),
    emissiveIntensity: 0.25
  });

  const layerGold = makeLayer({
    count: 7000,
    geometry: new THREE.IcosahedronGeometry(0.035, 0),
    material: goldMat,
    scale: 1.0
  });

  const layerEmerald = makeLayer({
    count: 1200,
    geometry: new THREE.SphereGeometry(0.05, 12, 12),
    material: emeraldMat,
    scale: 2.1
  });

  function updateLayer(layer, time, t){
    const { mesh, dual, count, scale } = layer;
    for(let i=0;i<count;i++){
      const { scatter, tree, seed } = dual[i];
      tempObj.position.lerpVectors(scatter, tree, t);

      const float = Math.sin((seed * 10 + time) * 1.2) * 0.03;
      tempObj.position.y += (1 - t) * float;

      const r = seed * Math.PI * 2;
      tempObj.rotation.set(r*(1-t), r*0.5, r*t);

      const s = scale*(0.6 + seed*0.8);
      tempObj.scale.setScalar(s);

      tempObj.updateMatrix();
      mesh.setMatrixAt(i, tempObj.matrix);
    }
    mesh.instanceMatrix.needsUpdate = true;
  }

  // ===== 中文祝福文本（Sprite 纹理） =====
  const wishes = [
    "祝裘阿姨圣诞快乐",
    "要身体健康！！",
    "更擅长发现生活中的美好！！",
    "所爱之人心想事成！！",
    "被更多的人尊敬",
    "继续做自己！！",
    "万事顺遂，心想事成❤️",
    "2025.12.24 & 25",
    "from：xxx"
  ];

  function roundRect(ctx, x, y, w, h, r){
    ctx.beginPath();
    ctx.moveTo(x+r,y);
    ctx.arcTo(x+w,y,x+w,y+h,r);
    ctx.arcTo(x+w,y+h,x,y+h,r);
    ctx.arcTo(x,y+h,x,y,r);
    ctx.arcTo(x,y,x+w,y,r);
    ctx.closePath();
  }

  function makeTextTexture(text){
    const padX = 26, padY = 18;
    const font = '600 44px "Noto Sans SC", "Inter", system-ui, sans-serif';

    const c = document.createElement("canvas");
    const ctx = c.getContext("2d");
    ctx.font = font;

    const w = Math.ceil(ctx.measureText(text).width + padX*2);
    const h = Math.ceil(60 + padY*2);

    c.width = w; c.height = h;
    ctx.font = font;

    ctx.fillStyle = "rgba(2,8,6,0.35)";
    roundRect(ctx, 0, 0, w, h, 18);
    ctx.fill();

    ctx.strokeStyle = "rgba(212,175,55,0.35)";
    ctx.lineWidth = 3;
    roundRect(ctx, 3, 3, w-6, h-6, 16);
    ctx.stroke();

    ctx.shadowColor = "rgba(212,175,55,0.28)";
    ctx.shadowBlur = 18;
    ctx.fillStyle = "#FFD58A";
    ctx.textBaseline = "middle";
    ctx.fillText(text, padX, h/2);

    const tex = new THREE.CanvasTexture(c);
    tex.colorSpace = THREE.SRGBColorSpace;
    tex.needsUpdate = true;
    return tex;
  }

  const textSprites = [];
  const textGroup = new THREE.Group();
  treeGroup.add(textGroup);

  const baseR = 3.9;
  for(let i=0;i<wishes.length;i++){
    const t = i / wishes.length;
    const ang = t * Math.PI * 2 + (i%2?0.35:-0.18);
    const r = baseR + (i%3)*0.35;
    const y = -2.0 + t*4.8 + (rand01(i*9.7)-0.5)*0.35;

    const tex = makeTextTexture(wishes[i]);
    const mat = new THREE.SpriteMaterial({
      map: tex,
      transparent: true,
      opacity: 0.95,
      depthTest: true,
      depthWrite: false
    });
    const sp = new THREE.Sprite(mat);
    const wScale = 1.6 + wishes[i].length*0.03;
    sp.scale.set(wScale, 0.55, 1);
    sp.position.set(Math.cos(ang)*r, y, Math.sin(ang)*r);
    sp.userData.basePos = sp.position.clone();
    textGroup.add(sp);
    textSprites.push(sp);
  }

  // 点击切换形态
  window.addEventListener("pointerdown", ()=>{
    morph.target = (morph.target === TreeMorphState.TREE_SHAPE)
      ? TreeMorphState.SCATTERED
      : TreeMorphState.TREE_SHAPE;
  });

  // ===== 动画循环 =====
  const clock = new THREE.Clock();
  let frameCount = 0;
  function animate(){
    requestAnimationFrame(animate);
    const dt = clock.getDelta();
    const time = clock.elapsedTime;
    frameCount++;

    // HUD 每秒更新一次
    if(frameCount % 30 === 0) hud.textContent = `JS: running...\nFrames: ${frameCount}`;

    // morph 推进
    if(morph.target !== morph.current){
      const dir = (morph.target === TreeMorphState.TREE_SHAPE) ? 1 : -1;
      morph.morphT = THREE.MathUtils.clamp(morph.morphT + dir*morph.speed*dt, 0, 1);
      const done = (dir===1 && morph.morphT>=1) || (dir===-1 && morph.morphT<=0);
      if(done) morph.current = morph.target;
    }
    const t = easeInOutCubic(morph.morphT);

    // 文本漂浮
    for(let i=0;i<textSprites.length;i++){
      const sp = textSprites[i];
      const base = sp.userData.basePos;
      sp.position.y = base.y + Math.sin(time*1.2 + i*0.7)*0.08;
    }

    updateLayer(layerGold, time, t);
    updateLayer(layerEmerald, time, t);

    camera.lookAt(0, 0.2, 0);
    renderer.render(scene, camera);
  }
  animate();

  window.addEventListener("resize", ()=>{
    renderer.setSize(window.innerWidth, window.innerHeight);
    camera.aspect = window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
  });
</script>
</body>
</html>
